1. JavaScript's asynchronous nature may be a pain point for many developers because it violates the "intuitive" basis through which most of us understand code. Humans naturally tend to view time as linear, and thus asynchronous code is much more confusing to write, understand, and debug. Loose typing is another large pain point for many developers because it can often lead to unintended behavior that can fly under the radar because JavaScript doesn't view it as "wrong" per se. In a strongly typed language, the compiler would throw an error if you tried to treat a string like an integer, but JavaScript just starts using monkey math (i.e. in the explore task). Furthermore, the web platform which Javascript runs on is a pain point because browsers are used by billions of people worldwide, and have poor standardization. One thing may work on the developer's computer, but then fail on some users' (i.e. Internet Explorer). This is especially dangerous because if something affects 0.1% of internet users, that's still multiple millions of people.
2. I believe that the JavaScript developers made the language loosely typed and added asynchronous features as a means of minimizing the pain that is created by the uncontrollable variety of web browsers and internet speeds. Since the behavior of the browser cannot be controlled for, it becomes much more difficult to write code that is always robust. By allowing the code to "work" in more cases without throwing an error, some of this uncontrollable nature can be swept under the rug.
3. The key difference between a compiled language and interpreted language is that compiled code is processed beforehand, and then run all at once, whereas interpreted code is processed line-by-line in real time. JavaScript is an interpreted language. A disadvantage to this is that compiled code usually runs faster, and is less dependant on external factors (i.e. the compiled file is precisely the machine code that runs). However, there are advantages to this. For one, JavaScript interacts with webpages that may change in real time, and thus compiled code may not account for all the various pathways that the code may need to take (i.e. relately to the loose nature of datatypes in Javascript). Also, interepted code doesn't have to account for various hardwares, which is important for JavaScript when considering that websites run on a crazy number of different browsers. 
4. I believe that Prof. Powell is focusing on vanilla JavaScript first because it is the basis upon which all JS frameworks are built. Once someone understands vanilla JS, it becomes much easier to pick up any framework, or switch between them. Furthermore, if a developer understands vanilla JS very well, they can more easily pick good frameworks later on, as well as understand how those frameworks work and their pros and cons. If someone first learns those frameworks, however, they become entrenched in it and would essentially have to relearn everything if they wanted to switch to a different framework. If we consider coding to be a pyramid of skills, we need to build out the base of the pyramid first or it will become unstable. However, not learning frameworks does have disadvantages. For one, we might have to reinvent the wheel addressing a problem that a framework has already solved. Or, if someone is motivated by what Powell called "resume-driven development", learning a framework is a fancy word that someone can add to their resume. 
5. I think that this lab relates to our project because we will inherently need our websites to be interactive and deal with user input. This lab addressed how to write that code (through JavaScript), how to ensure the code runs correctly (using debuggers), and how to lay down out a plan for how our website will work (with a flowchart). This helps us create websites carefully and intentionally, which leads to more robust code and a vastly better user experience.